# -*- coding: utf-8 -*-
"""TimesFM.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oT5Es-cZ11CnMSgc5K3e2N9uu93NLnA8
"""

!pip install git+https://github.com/google-research/timesfm.git
!pip install yfinance pandas numpy matplotlib

"""# Scarico la serie temporale"""

import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import torch
import timesfm
from sklearn.preprocessing import StandardScaler

print("Script di forecasting BTC-EUR con TimesFM 2.5 avviato...")

# --- 1. Impostazioni e Download Dati ---

TICKER = "BTC-EUR"
PERIODO_STORICO = "5y"
ORIZZONTE_FORECAST = 30
CONTEXT_LEN = 2048

try:
    data = yf.download(TICKER, period=PERIODO_STORICO, interval="1d", auto_adjust=True)
    if data.empty:
        raise ValueError(f"Nessun dato scaricato per {TICKER}.")

    time_series = data['Close'].dropna()
    print(f"Dati storici scaricati: {len(time_series)} punti dal {time_series.index.min().date()} al {time_series.index.max().date()}.")

except Exception as e:
    print(f"Errore during il download dei dati: {e}")
    exit()

"""# Visualizzo i dati storici"""

ORIZZONTE_FORECAST = 7

# --- 2. Plot Dati Storici ---
print("Visualizzazione dati storici...")
plt.figure(figsize=(12, 6))
plt.plot(time_series.index, time_series.values, label='Storico BTC-EUR (5 anni)')
plt.title(f'Storico {TICKER} ({PERIODO_STORICO})')
plt.xlabel('Data')
plt.ylabel('Prezzo (EUR)')
plt.legend()
plt.grid(True)
plt.show()

"""# Setup del modello"""

# --- 3. Setup Modello TimesFM 2.5 ---

print("Caricamento e configurazione del modello TimesFM 2.5 (200M Pytorch)...")

torch.set_float32_matmul_precision("high")
model = timesfm.TimesFM_2p5_200M_torch.from_pretrained("google/timesfm-2.5-200m-pytorch")

model.compile(
    timesfm.ForecastConfig(
        max_context=CONTEXT_LEN,
        max_horizon=ORIZZONTE_FORECAST + 1,
        normalize_inputs=False,
        use_continuous_quantile_head=True,
        force_flip_invariance=True,
        infer_is_positive=True,
        fix_quantile_crossing=True,
    )
)

"""# Esecuzione del forecasting"""

# --- 4. Esecuzione del Forecasting (con Sklearn) ---

if len(time_series) < CONTEXT_LEN:
    print(f"Attenzione: Dati storici ({len(time_series)}) inferiori al contesto ({CONTEXT_LEN}). Uso tutti i dati disponibili.")
    input_data = time_series.values
else:
    input_data = time_series.values[-CONTEXT_LEN:]

input_data_reshaped = input_data.reshape(-1, 1)

scaler = StandardScaler() # scaliamo i valori
normalized_input_data = scaler.fit_transform(input_data_reshaped)

inputs_list = [normalized_input_data.flatten().astype(np.float32)]


print(f"Effettuando il forecast per i prossimi {ORIZZONTE_FORECAST} giorni...")

point_forecast, quantile_forecast = model.forecast(
    horizon=ORIZZONTE_FORECAST,
    inputs=inputs_list,
)

# Estrai i risultati (che sono su scala normalizzata)

# <<< MODIFICA CHIAVE >>>
# point_forecast[0] è GIÀ l'array 1D (90,) che ci serve. Rimuoviamo il [0] extra.
normalized_forecast_values_1d = point_forecast[0]

# quantile_forecast[0] è l'array 2D (90, 10). Questo era corretto.
normalized_quantile_forecast_2d = quantile_forecast[0]


# --- Inizio De-Normalizzazione con Sklearn ---
# Ora 'normalized_forecast_values_1d' ha shape (90,)
normalized_forecast_2d_temp = normalized_forecast_values_1d.reshape(-1, 1)
forecast_values_2d = scaler.inverse_transform(normalized_forecast_2d_temp)
forecast_values = forecast_values_2d.flatten() # -> shape (90,) CORRETTO

# De-normalizza i quantili P10 (indice 1) e P90 (indice 8)
normalized_p10_2d = normalized_quantile_forecast_2d[:, 1].reshape(-1, 1)
normalized_p90_2d = normalized_quantile_forecast_2d[:, 8].reshape(-1, 1)

forecast_p10 = scaler.inverse_transform(normalized_p10_2d).flatten()
forecast_p90 = scaler.inverse_transform(normalized_p90_2d).flatten()
# --- Fine De-Normalizzazione ---

print("Forecast completato.")

"""# Visualizzazione risultati"""

# --- 5. Visualizzazione Risultati ---
# (Ora il loop e il plot funzioneranno)

print(f"\n--- Forecast Point-to-Point (Prossimi {ORIZZONTE_FORECAST} giorni) ---")
# Questo loop ora stamperà 90 righe
for i, val in enumerate(forecast_values):
    print(f"Giorno T+{i+1}: {val:.2f} EUR")

last_date = time_series.index[-1]
forecast_index = pd.date_range(start=last_date + pd.Timedelta(days=1), periods=ORIZZONTE_FORECAST, freq='D')

print("Visualizzazione forecast...")
plt.figure(figsize=(14, 7))

storico_recente = time_series.iloc[-365:]
plt.plot(storico_recente.index, storico_recente.values, label='Storico (Ultimo anno)', color='blue')

# Questo plot ora riceve x=(90,) e y=(90,)
plt.plot(forecast_index, forecast_values, label=f'Forecast (Point) {ORIZZONTE_FORECAST} giorni', color='orange', linestyle='--')
plt.fill_between(forecast_index, forecast_p10, forecast_p90, color='orange', alpha=0.2, label='Intervallo Quantile (10%-90%)')

plt.title(f'Forecast {TICKER} con TimesFM 2.5')
plt.xlabel('Data')
plt.ylabel('Prezzo (EUR)')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

print("Script terminato.")

# --- 6. Visualizzazione Interattiva con Plotly ---

print("Creazione visualizzazione interattiva con Plotly...")

import plotly.graph_objects as go
from plotly.subplots import make_subplots

# Crea un oggetto figura con subplots (opzionale, ma utile per futuri miglioramenti)
fig = go.Figure()

# Aggiungi la serie storica (ultimo anno)
fig.add_trace(go.Scatter(
    x=storico_recente.index,
    y=storico_recente.values.flatten(), # Assicurati che sia un array 1D
    mode='lines',
    name='Storico (Ultimo anno)',
    line=dict(color='blue')
))

# Aggiungi il forecast point-to-point
fig.add_trace(go.Scatter(
    x=forecast_index,
    y=forecast_values,
    mode='lines',
    name=f'Forecast (Point) {ORIZZONTE_FORECAST} giorni',
    line=dict(color='orange', dash='dash')
))

# Aggiungi l'intervallo quantile (P10-P90)
fig.add_trace(go.Scatter(
    x=np.concatenate([forecast_index, forecast_index[::-1]]), # Concatena gli indici per l'area
    y=np.concatenate([forecast_p90, forecast_p10[::-1]]),     # Concatena P90 e P10 invertito per chiudere l'area
    fill='toself',
    fillcolor='rgba(255, 165, 0, 0.2)', # Arancione trasparente
    line=dict(color='rgba(255,255,255,0)'), # Rimuovi la linea del contorno
    name='Intervallo Quantile (10%-90%)'
))

# Aggiorna il layout del grafico
fig.update_layout(
    title=f'Forecast Interattivo {TICKER} con TimesFM 2.5',
    xaxis_title='Data',
    yaxis_title='Prezzo (EUR)',
    hovermode='x unified', # Mostra i dati per la stessa data su tutte le tracce
    template='plotly_white' # Utilizza un template pulito
)

# Mostra il grafico interattivo
fig.show()

print("Visualizzazione interattiva creata.")